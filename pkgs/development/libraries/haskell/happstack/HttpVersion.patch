--- ./src/Happstack/Server/FastCGI.hs	2013-12-30 18:21:26.765265522 -0500
+++ ./src/Happstack/Server/FastCGI.hs.patched	2013-12-30 19:42:47.147349894 -0500
@@ -19,8 +19,11 @@
 import Data.Char (toLower)
 import Data.List (isPrefixOf)
 import Happstack.Server
-import Happstack.Server.HTTP.Types (Request (..), Version (Version))
+import Happstack.Server.Types (Request (..), HttpVersion (HttpVersion))
+import Happstack.Server.Internal.Monads(runServerPartT)
 import Network.CGI.Monad (CGIRequest, cgiVars, cgiRequestBody, cgiGet)
+import Happstack.Server.Internal.Cookie (parseCookies)
+import Control.Concurrent.MVar (newMVar, MVar(..))
 import Network.CGI.Protocol (maybeRead)
 import Network.FastCGI
 import qualified Data.ByteString.Lazy as BS
@@ -57,15 +60,16 @@
 toHappstackRequest :: CGIRequest -> CGI Request
 toHappstackRequest rq = do
   i <- cgiInputs
+  b <- cgiBody rq
   return $ Request { rqMethod  = cgiMethod  rq
                    , rqPaths   = cgiPaths   rq
                    , rqUri	   = cgiUri     rq
                    , rqQuery   = cgiQuery   rq
-                   , rqInputs  = i
+                   , rqInputsQuery  = i
                    , rqCookies = cgiCookies rq
                    , rqVersion = cgiVersion rq
                    , rqHeaders = cgiHeaders rq
-                   , rqBody    = cgiBody    rq
+                   , rqBody    = b
                    , rqPeer    = cgiPeer    rq
                    }
 
@@ -101,7 +105,7 @@
 cgiCookies :: CGIRequest -> [(String, H.Cookie)]
 cgiCookies = map cookieWithName . either (const []) id . parseCookies . str "HTTP_COOKIE"
 
-cgiVersion :: CGIRequest -> Version
+cgiVersion :: CGIRequest -> HttpVersion
 cgiVersion = parseProtocol . str "SERVER_PROTOCOL"
 
 cgiHeaders :: CGIRequest -> Headers
@@ -111,8 +115,8 @@
            . M.toList
            . cgiVars
 
-cgiBody :: CGIRequest -> RqBody
-cgiBody = Body . cgiRequestBody
+cgiBody :: CGIRequest -> CGI (MVar RqBody)
+cgiBody = liftIO . newMVar . Body . cgiRequestBody
 
 cgiPeer :: CGIRequest -> (String, Int)
 cgiPeer r = (str "REMOTE_ADDR" r, withDef 0 (r ? "REMOTE_PORT" >>= maybeRead)) -- TODO
@@ -135,10 +139,10 @@
 
 
 -- | Parse the HTTP protocol
-parseProtocol :: String -> Version
-parseProtocol "HTTP/0.9" = Version 0 9
-parseProtocol "HTTP/1.0" = Version 1 0
-parseProtocol "HTTP/1.1" = Version 1 1
+parseProtocol :: String -> HttpVersion
+parseProtocol "HTTP/0.9" = HttpVersion 0 9
+parseProtocol "HTTP/1.0" = HttpVersion 1 0
+parseProtocol "HTTP/1.1" = HttpVersion 1 1
 parseProtocol _          = error "Invalid HTTP Version"
 
 -- | Gives an input key/value given an input key
@@ -147,7 +151,7 @@
   filename    <- getInputFilename k
   value       <- withDef (BS.empty) <$> getInputFPS k
   contentType <- withDef ""         <$> getInputContentType k
-  return (k,  Input { inputValue       = value
+  return (k,  Input { inputValue       = Right value
                     , inputFilename    = filename
                     , inputContentType = convertContentType $ parseContentType contentType 
                     })
@@ -160,10 +164,7 @@
 
 -- | Transforms a ServerPartT into a function. This is a copy of simpleHTTP'
 processRequest :: (ToMessage b, Monad m, Functor m) => ServerPartT m b -> Request -> m Response
-processRequest hs req =  (runWebT $ runServerPartT hs req) >>= (return . (maybe standardNotFound id))
-    where
-        standardNotFound = H.setHeader "Content-Type" "text/html" $ toResponse "Not found"
-
+processRequest = simpleHTTP''
 
 --------------------------------------------------
 -- Copied straight from Lemmih's old happs-fastcgi
